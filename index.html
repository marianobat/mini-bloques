<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>STEAM Pathfinder (embed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      --frame-w: 380px;       /* ancho m√°ximo del frame embebible */
      --cell: 64px;           /* tama√±o de celda m√°s chico */
      --pad: 8px;             /* padding del canvas */
    }
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, sans-serif; background: #fff; -webkit-font-smoothing: antialiased; }
    /* Evitar selecci√≥n de texto al arrastrar bloques */
    * { -webkit-user-select:none; user-select:none; }

    .wrap {
      display: grid;
      grid-template-columns: minmax(320px, var(--frame-w)) 1fr;
      gap: 10px;
      padding: 8px;
      box-sizing: border-box;
      max-height: 100vh;
    }

    /* FRAME ANGOSTO (canvas + controles) */
    .frame {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(31,41,55,.08);
      background:#fff;
      overflow: hidden;
      display:flex;
      flex-direction: column;
      align-items: stretch;
    }
    .controls {
      display:flex; gap:6px; padding:8px;
      border-bottom: 1px solid #f1f5f9;
      align-items:center; justify-content:center;
    }
    button {
      padding:8px 12px; border-radius:10px; border:1px solid #cbd5e1;
      background:#f8fafc; cursor:pointer; font-size:16px; line-height:1;
    }
    button:hover { background:#eef2ff; }
    #status { padding:8px 10px; font-weight:600; text-align:center; min-height:24px; }
    #status.ok { color:#0a7a27; }
    #status.err { color:#b00020; }

    .boardArea { display:flex; align-items:center; justify-content:center; padding:8px; }
    #board { border:1px solid #e5e7eb; background:#fff; border-radius:8px; }

    /* Blockly a la derecha (visible) */
    .side {
      display:flex; flex-direction:column; gap:8px; min-width:300px;
    }
    #blocklyDiv {
      width: 100%;
      height: 420px;                  /* m√°s compacto */
      border: 1px solid #e6e6e6; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(31,41,55,.08);
    }
    .blocklyToolboxDiv { border-right: 1px solid #e5e7eb; background: #ffffff !important; }
    .blocklyFlyoutBackground { fill: #f8fafc !important; }

    /* Responsive: si el ancho es chico, apilar */
    @media (max-width: 900px){
      .wrap{ grid-template-columns: 1fr; }
      .side { min-width: unset; }
    }
  </style>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body>
  <div class="wrap">
    <!-- FRAME ANGOSTO EMBEBIBLE -->
    <div class="frame">
      <div class="controls">
        <button id="btnPlay" title="Reproducir / Pausar">‚ñ∂</button>
        <button id="btnRestart" title="Reiniciar">‚Ü∫</button>
        <button id="btnClean" title="Limpiar">üßπ</button>
      </div>
      <div id="status"></div>
      <div class="boardArea">
        <canvas id="board"></canvas>
      </div>
    </div>

    <!-- Blockly visible con SOLO bloques de movimiento -->
    <div class="side">
      <div id="blocklyDiv"></div>
      <xml id="toolbox" style="display:none">
        <block type="move_forward"></block>
        <block type="turn_left"></block>
        <block type="turn_right"></block>
      </xml>
    </div>
  </div>

  <script>
    // ======= Tema (playful) + renderer zelos =======
    const playfulTheme = Blockly.Theme.defineTheme('playful', {
      base: Blockly.Themes.Classic,
      componentStyles: {
        workspaceBackgroundColour: '#fafbff',
        toolboxBackgroundColour: '#ffffff',
        toolboxForegroundColour: '#1f2937',
        flyoutBackgroundColour: '#ffffff',
        insertionMarkerColour: '#4C97FF',
        insertionMarkerOpacity: 0.3,
        scrollbarColour: '#c7d2fe'
      }
    });

    // ======= Assets opcionales (si no existen, se dibuja fallback) =======
    const IMAGES = { robot: new Image(), icons:{ move:new Image(), left:new Image(), right:new Image() } };
    IMAGES.robot.src = './assets/robot.svg';
    IMAGES.icons.move.src = './assets/icons/move.svg';
    IMAGES.icons.left.src = './assets/icons/left.svg';
    IMAGES.icons.right.src = './assets/icons/right.svg';

    // ======= Bloques m√≠nimos =======
    Blockly.Blocks['start_hat'] = {
      init: function() {
        this.appendDummyInput().appendField("Play");
        this.setNextStatement(true);
        this.setColour("#4C97FF");
        this.setDeletable(false);
        this.setMovable(true);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
      }
    };
    Blockly.Blocks['move_forward'] = {
      init: function() {
        const exists = IMAGES.icons.move.complete && IMAGES.icons.move.naturalWidth>0;
        const input = this.appendDummyInput();
        if (exists) input.appendField(new Blockly.FieldImage('./assets/icons/move.svg', 24, 24, '*'));
        input.appendField("avanzar");
        this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#9966FF");
      }
    };
    Blockly.Blocks['turn_left'] = {
      init: function() {
        const exists = IMAGES.icons.left.complete && IMAGES.icons.left.naturalWidth>0;
        const input = this.appendDummyInput();
        if (exists) input.appendField(new Blockly.FieldImage('./assets/icons/left.svg', 24, 24, '*'));
        input.appendField("girar izquierda");
        this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#9966FF");
      }
    };
    Blockly.Blocks['turn_right'] = {
      init: function() {
        const exists = IMAGES.icons.right.complete && IMAGES.icons.right.naturalWidth>0;
        const input = this.appendDummyInput();
        if (exists) input.appendField(new Blockly.FieldImage('./assets/icons/right.svg', 24, 24, '*'));
        input.appendField("girar derecha");
        this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#9966FF");
      }
    };

    // ======= Workspace =======
    const workspace = Blockly.inject('blocklyDiv', {
      toolbox: document.getElementById('toolbox'),
      scrollbars: true,
      trashcan: true,
      zoom: { controls: true, wheel: true },
      comments: false,
      collapse: false,
      media: 'https://unpkg.com/blockly/media/',
      renderer: 'zelos',
      theme: playfulTheme
    });

    function ensureStartHat() {
      const hats = workspace.getTopBlocks(true).filter(b => b.type === 'start_hat');
      if (hats.length === 0) {
        const block = workspace.newBlock('start_hat');
        block.initSvg(); block.render();
        block.moveBy(20, 20);
      }
    }
    ensureStartHat();

    // ======= Par√°metros del escenario (3x5) =======
    const GRID_W = 5;   // columnas
    const GRID_H = 3;   // filas
    const CELL = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) || 64;
    const PAD  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pad')) || 8;

    // Robot arranca en (0,0)
    const startState = { x: 0, y: 0, dir: 0 }; // 0=Este,1=Sur,2=Oeste,3=Norte

    // Letras STEAM en la fila central (y = 1)
    const LETTERS = [
      { ch: 'S', x: 0, y: 1, lit: false, color: null },
      { ch: 'T', x: 1, y: 1, lit: false, color: null },
      { ch: 'E', x: 2, y: 1, lit: false, color: null },
      { ch: 'A', x: 3, y: 1, lit: false, color: null },
      { ch: 'M', x: 4, y: 1, lit: false, color: null },
    ];

    // Colores por letra (f√°cil de cambiar luego)
    const LETTER_COLORS = {
      S: '#c7e0ff',  // azul claro
      T: '#ffd6a5',  // durazno
      E: '#c8f7c5',  // verde claro
      A: '#ffe3e3',  // rosado claro
      M: '#e7d5ff'   // violeta claro
    };

    function lightIfLetter(x, y) {
      const idx = LETTERS.findIndex(L => L.x === x && L.y === y);
      if (idx >= 0) {
        LETTERS[idx].lit = true;
        const ch = LETTERS[idx].ch;
        LETTERS[idx].color = LETTER_COLORS[ch] || '#c7e0ff';
      }
    }
    function allLit() { return LETTERS.every(L => L.lit); }

    // ======= Movimiento del robot =======
    function move(robot) {
      let nx = robot.x, ny = robot.y;
      if (robot.dir === 0) nx += 1;
      else if (robot.dir === 1) ny += 1;
      else if (robot.dir === 2) nx -= 1;
      else if (robot.dir === 3) ny -= 1;

      if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
        robot.x = nx; robot.y = ny;
        lightIfLetter(robot.x, robot.y);
      } else {
        robot.outOfBounds = true;
      }
    }

    // ======= Dibujo =======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    canvas.width  = PAD*2 + CELL*GRID_W;
    canvas.height = PAD*2 + CELL*GRID_H;

    function drawBoard(robot = startState) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0,0,canvas.width,canvas.height);

      // Grilla
      ctx.strokeStyle = '#e5e7eb';
      for (let i=0;i<=GRID_W;i++) {
        ctx.beginPath(); ctx.moveTo(PAD + i*CELL, PAD); ctx.lineTo(PAD + i*CELL, PAD + GRID_H*CELL); ctx.stroke();
      }
      for (let j=0;j<=GRID_H;j++) {
        ctx.beginPath(); ctx.moveTo(PAD, PAD + j*CELL); ctx.lineTo(PAD + GRID_W*CELL, PAD + j*CELL); ctx.stroke();
      }

      // Letras
      LETTERS.forEach(L => drawLetterCell(L));

      // Robot
      drawRobot(robot.x, robot.y, robot.dir, robot.outOfBounds || false);
    }

    function drawLetterCell(L) {
      const px = PAD + L.x*CELL, py = PAD + L.y*CELL;
      const litColor = L.color || '#fff7cc'; // apagado
      ctx.fillStyle = L.lit ? litColor : '#fff7cc';
      ctx.fillRect(px+2, py+2, CELL-4, CELL-4);

      ctx.fillStyle = '#1f2937';
      ctx.font = 'bold 32px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(L.ch, px + CELL/2, py + CELL/2);

      ctx.strokeStyle = L.lit ? '#334155' : '#eab308';
      ctx.lineWidth = 2;
      ctx.strokeRect(px+5, py+5, CELL-10, CELL-10);
    }

    function drawRobot(x, y, dir, outOfBounds=false) {
      const cx = PAD + x*CELL + CELL/2;
      const cy = PAD + y*CELL + CELL/2;
      const angle = [0, Math.PI/2, Math.PI, -Math.PI/2][dir] || 0;
      const size = CELL * 0.6;
      if (IMAGES.robot && IMAGES.robot.complete && IMAGES.robot.naturalWidth > 0) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.drawImage(IMAGES.robot, -size/2, -size/2, size, size);
        if (outOfBounds) {
          ctx.strokeStyle = '#e23'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(0, 0, size*0.55, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      } else {
        const r = CELL*0.28;
        ctx.fillStyle = outOfBounds ? '#e23' : '#4C97FF';
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
        const nx = cx + Math.cos(angle) * (r+10);
        const ny = cy + Math.sin(angle) * (r+10);
        ctx.strokeStyle = '#003A99'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(nx, ny); ctx.stroke();
      }
    }

    function setStatus(msg, error=false) {
      const el = document.getElementById('status');
      el.textContent = msg; el.className = error ? 'err' : (msg ? 'ok' : '');
    }

    drawBoard();

    // ======= Ejecuci√≥n =======
    let running = false;
    let intervalId = null;
    let compiled = [];
    let runIdx = 0;
    let robot = { ...startState, outOfBounds: false };

    function compileProgram() {
      compiled = [];
      const top = workspace.getTopBlocks(true).find(b => b.type === 'start_hat');
      if (!top) return;

      function compileBlock(block) {
        if (!block) return;
        switch (block.type) {
          case 'move_forward': compiled.push({ cmd: 'move', id: block.id }); break;
          case 'turn_left':    compiled.push({ cmd: 'left', id: block.id }); break;
          case 'turn_right':   compiled.push({ cmd: 'right', id: block.id }); break;
        }
      }
      function compileChain(block) {
        let b = block;
        while (b) { compileBlock(b); b = b.getNextBlock(); }
      }
      compileChain(top.getNextBlock());
    }

    function stepOnce() {
      if (runIdx >= compiled.length) { toggleAuto(); return; }
      const step = compiled[runIdx++];
      try { workspace.highlightBlock(step.id); } catch(e) {}

      switch (step.cmd) {
        case 'move':  move(robot); break;
        case 'left':  robot.dir = (robot.dir + 3) % 4; break;
        case 'right': robot.dir = (robot.dir + 1) % 4; break;
      }

      drawBoard(robot);

      if (robot.outOfBounds) {
        setStatus('¬°Fuera de l√≠mites!', true);
        toggleAuto();
        return;
      }
      if (allLit()) {
        setStatus('¬°Ganaste! STEAM encendidas ‚úÖ');
        toggleAuto();
        return;
      }
    }

    function toggleAuto() {
      if (running) {
        running = false; clearInterval(intervalId); intervalId = null;
        try { workspace.highlightBlock(null); } catch(e){}
        document.getElementById('btnPlay').textContent = '‚ñ∂';
      } else {
        // reset
        LETTERS.forEach(L => { L.lit = false; L.color = null; });
        lightIfLetter(startState.x, startState.y);

        compileProgram();
        runIdx = 0;
        robot = { ...startState, outOfBounds: false };
        try { workspace.highlightBlock(null); } catch(e){}
        setStatus('');
        drawBoard(robot);
        running = true;
        intervalId = setInterval(stepOnce, 380);
        document.getElementById('btnPlay').textContent = '‚è∏';
      }
    }

    function restartRun() {
      if (running) toggleAuto();
      LETTERS.forEach(L => { L.lit = false; L.color = null; });
      lightIfLetter(startState.x, startState.y);
      runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      try { workspace.highlightBlock(null); } catch(e){}
      setStatus('');
      drawBoard(robot);
    }

    function cleanWorkspace() {
      if (running) toggleAuto();
      workspace.clear();
      const block = workspace.newBlock('start_hat');
      block.initSvg(); block.render();
      block.moveBy(20, 20);
      LETTERS.forEach(L => { L.lit = false; L.color = null; });
      lightIfLetter(startState.x, startState.y);
      compiled = []; runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      try { workspace.highlightBlock(null); } catch(e){}
      setStatus('');
      drawBoard(robot);
    }

    document.getElementById('btnPlay').onclick = toggleAuto;
    document.getElementById('btnRestart').onclick = restartRun;
    document.getElementById('btnClean').onclick = cleanWorkspace;
  </script>
</body>
</html>
