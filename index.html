<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>STEAM Pathfinder (embed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      --frame-w: 380px;   /* ancho del frame embebible */
      --cell: 64px;       /* tamaÃ±o de celda */
      --pad: 8px;         /* padding del canvas */
    }
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, sans-serif; background: #fff; -webkit-font-smoothing: antialiased; }
    * { -webkit-user-select:none; user-select:none; }

    .wrap {
      display: grid;
      grid-template-columns: minmax(320px, var(--frame-w)) 1fr;
      gap: 12px; padding: 10px; box-sizing: border-box; max-height: 100vh;
      background: radial-gradient(circle at 20% 20%, #f1f5ff 0, transparent 28%), radial-gradient(circle at 80% 10%, #fff4e6 0, transparent 30%);
    }

    /* FRAME angosto (canvas + controles) */
    .frame {
      border: 1px solid #e5e7eb; border-radius: 14px;
      box-shadow: 0 12px 30px rgba(31,41,55,.12);
      background:#fff; overflow: hidden;
      display:flex; flex-direction: column; align-items: stretch;
    }
    .controls {
      display:flex; gap:10px; padding:10px 12px;
      border-bottom: 1px solid #f1f5f9; align-items:center; justify-content:center;
      background: linear-gradient(120deg, #eef2ff, #f8fafc);
    }
    button {
      padding:10px 14px; border-radius:12px; border:1px solid #cbd5e1;
      background:#fff; cursor:pointer; font-size:16px; line-height:1;
      transition: transform 150ms ease, box-shadow 150ms ease, background 150ms ease;
      box-shadow: 0 6px 16px rgba(59,130,246,0.08);
    }
    button:hover { background:#eef2ff; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    #status { padding:8px 10px; font-weight:600; text-align:center; min-height:24px; color:#0ea5e9; }
    #status.ok { color:#0a7a27; }
    #status.err { color:#b00020; }

    .boardArea { display:flex; align-items:center; justify-content:center; padding:8px; }
    #board { border:1px solid #e5e7eb; background:#fff; border-radius:10px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.8); }

    /* Blockly a la derecha (visible) */
    .side { display:flex; flex-direction:column; gap:8px; min-width:300px; }
    #blocklyDiv {
      width: 100%; height: 420px;
      border: 1px solid #e6e6e6; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(31,41,55,.08);
    }
    .blocklyToolboxDiv { border-right: 1px solid #e5e7eb; background: #ffffff !important; }
    .blocklyFlyoutBackground { fill: #f8fafc !important; }

    /* Modal de victoria */
    .modal-backdrop {
      position: fixed; inset: 0; background: rgba(15,23,42,.55);
      display: flex; align-items: center; justify-content: center; z-index: 50;
      opacity: 0; pointer-events: none;
      transition: opacity 200ms ease;
    }
    .modal {
      background: linear-gradient(160deg, #ffffff, #f8fafc);
      border-radius: 16px; padding: 20px;
      width: min(92vw, 380px); box-shadow: 0 20px 50px rgba(0,0,0,.25);
      text-align: center;
      transform: translateY(10px) scale(0.98);
      transition: transform 220ms ease, opacity 220ms ease;
      opacity: 0;
    }
    .modal h3 { margin: 0 0 6px; font-size: 20px; }
    .modal p { margin: 0 0 14px; color:#334155; }
    .modal .actions { display:flex; gap:10px; justify-content:center; }
    .modal a, .modal button {
      padding:10px 14px; border-radius:10px; border:1px solid #cbd5e1; text-decoration:none;
      font-weight:600; cursor:pointer;
    }
    .modal a { background:#111827; color:#fff; }
    .modal button { background:#f8fafc; }
    .modal-backdrop.show { opacity: 1; pointer-events: auto; }
    .modal-backdrop.show .modal { transform: translateY(0) scale(1); opacity: 1; }

    @media (max-width: 900px){
      .wrap{ grid-template-columns: 1fr; }
      .side { min-width: unset; }
    }
  </style>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body>
  <div class="wrap">
    <!-- FRAME ANGOSTO EMBEBIBLE -->
    <div class="frame">
      <div class="controls">
        <button id="btnPlay" title="Reproducir / Pausar">â–¶</button>
        <button id="btnRestart" title="Reiniciar">â†º</button>
        <button id="btnClean" title="Limpiar">ðŸ§¹</button>
      </div>
      <div id="status"></div>
      <div class="boardArea">
        <canvas id="board"></canvas>
      </div>
    </div>

    <!-- Blockly visible con SOLO bloques de movimiento -->
    <div class="side">
      <div id="blocklyDiv"></div>
      <xml id="toolbox" style="display:none">
        <block type="move_forward"></block>
        <block type="turn_left"></block>
        <block type="turn_right"></block>
      </xml>
    </div>
  </div>

  <!-- MODAL DE VICTORIA -->
  <div id="winBackdrop" class="modal-backdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h3>Â¡Ganaste! ðŸŽ‰</h3>
      <p>Tus estudiantes tambiÃ©n pueden aprender con <strong>SmartTEAM</strong>.</p>
      <div class="actions">
        <a href="https://smartteamdigital.com/" target="_blank" rel="noopener noreferrer">Conocer mÃ¡s</a>
        <button id="btnCerrarModal">Cerrar</button>
      </div>
    </div>
  </div>

  <script>
    // ======= Assets externos =======
    const ICON_MOVE_URL  = './assets/icons/move.svg';
    const ICON_LEFT_URL  = './assets/icons/left.svg';
    const ICON_RIGHT_URL = './assets/icons/right.svg';
    const ROBOT_URL      = './assets/robot.svg'; // opcional

    // ======= Tema + renderer =======
    const playfulTheme = Blockly.Theme.defineTheme('playful', {
      base: Blockly.Themes.Classic,
      componentStyles: {
        workspaceBackgroundColour: '#fafbff',
        toolboxBackgroundColour: '#ffffff',
        toolboxForegroundColour: '#1f2937',
        flyoutBackgroundColour: '#ffffff',
        insertionMarkerColour: '#4C97FF',
        insertionMarkerOpacity: 0.3,
        scrollbarColour: '#c7d2fe'
      }
    });

    // ======= Bloques mÃ­nimos (siempre muestran imagen externa) =======
    Blockly.Blocks['start_hat'] = {
      init: function() {
        this.appendDummyInput().appendField("Programa");
        this.setNextStatement(true);
        this.setColour("#ffc634");
        this.setDeletable(false);
        this.setMovable(true);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
      }
    };
    Blockly.Blocks['move_forward'] = {
      init: function() {
        this.appendDummyInput()
          .appendField(new Blockly.FieldImage(ICON_MOVE_URL, 24, 24, '*'))
          .appendField("avanza");
        this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#9966FF");
      }
    };
    Blockly.Blocks['turn_left'] = {
      init: function() {
        this.appendDummyInput()
          .appendField(new Blockly.FieldImage(ICON_LEFT_URL, 24, 24, '*'))
          .appendField("izquierda");
        this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#9966FF");
      }
    };
    Blockly.Blocks['turn_right'] = {
      init: function() {
        this.appendDummyInput()
          .appendField(new Blockly.FieldImage(ICON_RIGHT_URL, 24, 24, '*'))
          .appendField("derecha");
        this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#9966FF");
      }
    };

    // ======= Workspace =======
    const workspace = Blockly.inject('blocklyDiv', {
      toolbox: document.getElementById('toolbox'),
      scrollbars: true,
      trashcan: true,
      zoom: { controls: true, wheel: true },
      comments: false,
      collapse: false,
      media: 'https://unpkg.com/blockly/media/',
      renderer: 'zelos',
      theme: playfulTheme
    });

    function ensureStartHat() {
      const hats = workspace.getTopBlocks(true).filter(b => b.type === 'start_hat');
      if (hats.length === 0) {
        const block = workspace.newBlock('start_hat');
        block.initSvg(); block.render();
        block.moveBy(20, 20);
      }
    }
    ensureStartHat();

    // ======= ParÃ¡metros del escenario (3x5) =======
    const GRID_W = 5;   // columnas
    const GRID_H = 3;   // filas
    const CELL = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) || 64;
    const PAD  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pad')) || 8;

    // Robot arranca en (0,0)
    const startState = { x: 0, y: 0, dir: 0 }; // 0=Este,1=Sur,2=Oeste,3=Norte

    // Letras STEAM en la fila central (y = 1)
    const LETTERS = [
      { ch: 'S', x: 0, y: 1, lit: false, color: null },
      { ch: 'T', x: 1, y: 1, lit: false, color: null },
      { ch: 'E', x: 2, y: 1, lit: false, color: null },
      { ch: 'A', x: 3, y: 1, lit: false, color: null },
      { ch: 'M', x: 4, y: 1, lit: false, color: null },
    ];

    // Colores por letra (fÃ¡cil de cambiar luego)
    const LETTER_COLORS = {
      S: '#c7e0ff',  // azul claro
      T: '#ffd6a5',  // durazno
      E: '#c8f7c5',  // verde claro
      A: '#ffe3e3',  // rosado claro
      M: '#e7d5ff'   // violeta claro
    };

    function lightIfLetter(x, y) {
      const idx = LETTERS.findIndex(L => L.x === x && L.y === y);
      if (idx >= 0) {
        LETTERS[idx].lit = true;
        const ch = LETTERS[idx].ch;
        LETTERS[idx].color = LETTER_COLORS[ch] || '#c7e0ff';
      }
    }
    function allLit() { return LETTERS.every(L => L.lit); }

    // ======= Movimiento del robot =======
    function nextPosition(x, y, dir) {
      if (dir === 0) return { x: x + 1, y };
      if (dir === 1) return { x, y: y + 1 };
      if (dir === 2) return { x: x - 1, y };
      return { x, y: y - 1 };
    }

    // ======= Dibujo =======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    canvas.width  = PAD*2 + CELL*GRID_W;
    canvas.height = PAD*2 + CELL*GRID_H;

    let gameWon = false;

    // Carga opcional del robot SVG externo (si existe)
    const robotImg = new Image();
    robotImg.src = ROBOT_URL;
    robotImg.onload  = () => drawBoard();
    robotImg.onerror = () => drawBoard();

    function drawBoard(robot = startState, animationHint = null) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0,0,canvas.width,canvas.height);

      // Grilla
      ctx.strokeStyle = '#e5e7eb';
      for (let i=0;i<=GRID_W;i++) {
        ctx.beginPath(); ctx.moveTo(PAD + i*CELL, PAD); ctx.lineTo(PAD + i*CELL, PAD + GRID_H*CELL); ctx.stroke();
      }
      for (let j=0;j<=GRID_H;j++) {
        ctx.beginPath(); ctx.moveTo(PAD, PAD + j*CELL); ctx.lineTo(PAD + GRID_W*CELL, PAD + j*CELL); ctx.stroke();
      }

      // Letras
      LETTERS.forEach(L => drawLetterCell(L));

      // Robot (no dibujar si ganÃ³)
      if (!gameWon) {
        drawRobot(robot.x, robot.y, robot.dir, robot.outOfBounds || false);
      }

      // Si hay animaciÃ³n de choque, resaltamos la celda con un destello
      if (animationHint?.type === 'bump') {
        const { x, y } = animationHint.from;
        const px = PAD + x*CELL, py = PAD + y*CELL;
        ctx.strokeStyle = 'rgba(220,38,38,0.8)';
        ctx.lineWidth = 4;
        ctx.strokeRect(px+4, py+4, CELL-8, CELL-8);
      }
    }

    function drawLetterCell(L) {
      const px = PAD + L.x*CELL, py = PAD + L.y*CELL;
      const litColor = L.color || '#fff7cc'; // apagado
      ctx.fillStyle = L.lit ? litColor : '#fff7cc';
      ctx.fillRect(px+2, py+2, CELL-4, CELL-4);

      ctx.fillStyle = '#1f2937';
      ctx.font = 'bold 32px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(L.ch, px + CELL/2, py + CELL/2);

      ctx.strokeStyle = L.lit ? '#334155' : '#eab308';
      ctx.lineWidth = 2;
      ctx.strokeRect(px+5, py+5, CELL-10, CELL-10);
    }

    function drawRobot(x, y, dir, outOfBounds=false) {
      const cx = PAD + x*CELL + CELL/2;
      const cy = PAD + y*CELL + CELL/2;
      const angle = (dir || 0) * (Math.PI / 2); // soporta rotaciones fraccionarias
      const size = CELL * 0.6;

      if (robotImg.complete && robotImg.naturalWidth > 0) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.drawImage(robotImg, -size/2, -size/2, size, size);
        if (outOfBounds) {
          ctx.strokeStyle = '#e23'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(0, 0, size*0.55, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      } else {
        // Fallback simple si no hay SVG
        const r = CELL*0.28;
        ctx.fillStyle = outOfBounds ? '#e23' : '#4C97FF';
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
        const nx = cx + Math.cos(angle) * (r+10);
        const ny = cy + Math.sin(angle) * (r+10);
        ctx.strokeStyle = '#003A99'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(nx, ny); ctx.stroke();
      }
    }

    function setStatus(msg, error=false) {
      const el = document.getElementById('status');
      el.textContent = msg; el.className = error ? 'err' : (msg ? 'ok' : '');
    }

    // ======= Modal =======
    const backdrop = document.getElementById('winBackdrop');
    const btnCerrarModal = document.getElementById('btnCerrarModal');
    btnCerrarModal.addEventListener('click', () => backdrop.classList.remove('show'));
    backdrop.addEventListener('click', (e) => { if (e.target === backdrop) backdrop.classList.remove('show'); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') backdrop.classList.remove('show'); });
    function showWinModal() { backdrop.classList.add('show'); }

    drawBoard();
    setStatus('Arma tu programa y presiona â–¶');

    // ======= EjecuciÃ³n con animaciones suaves =======
    const STEP_DURATION = 520;
    const TURN_DURATION = 380;

    let running = false;
    let rafId = null;
    let compiled = [];
    let runIdx = 0;
    let robot = { ...startState, outOfBounds: false };
    let animation = { active: false };

    function compileProgram() {
      compiled = [];
      const top = workspace.getTopBlocks(true).find(b => b.type === 'start_hat');
      if (!top) return;

      function compileBlock(block) {
        if (!block) return;
        switch (block.type) {
          case 'move_forward': compiled.push({ cmd: 'move', id: block.id }); break;
          case 'turn_left':    compiled.push({ cmd: 'left', id: block.id }); break;
          case 'turn_right':   compiled.push({ cmd: 'right', id: block.id }); break;
        }
      }
      function compileChain(block) {
        let b = block;
        while (b) { compileBlock(b); b = b.getNextBlock(); }
      }
      compileChain(top.getNextBlock());
    }

    const ease = t => 1 - Math.pow(1 - t, 3); // easeOutCubic

    function startStep(step, timestamp) {
      try { workspace.highlightBlock(step.id); } catch(e) {}
      const from = { ...robot };
      const base = { active: true, start: timestamp, step, from };

      if (step.cmd === 'move') {
        const next = nextPosition(robot.x, robot.y, robot.dir);
        const inBounds = next.x >= 0 && next.x < GRID_W && next.y >= 0 && next.y < GRID_H;
        if (inBounds) {
          animation = { ...base, type: 'move', to: { ...next, dir: robot.dir }, duration: STEP_DURATION };
        } else {
          // pequeÃ±a sacudida indicando choque
          const dx = next.x - robot.x;
          const dy = next.y - robot.y;
          animation = {
            ...base,
            type: 'bump',
            to: { x: robot.x + dx * 0.15, y: robot.y + dy * 0.15, dir: robot.dir },
            duration: 280
          };
        }
        return;
      }

      if (step.cmd === 'left' || step.cmd === 'right') {
        const dirDelta = step.cmd === 'left' ? -1 : 1;
        const toDir = (robot.dir + 4 + dirDelta) % 4;
        animation = { ...base, type: 'turn', to: { ...robot, dir: toDir }, duration: TURN_DURATION };
        return;
      }
    }

    function finalizeStep(step) {
      if (animation.type === 'move') {
        const target = nextPosition(animation.from.x, animation.from.y, animation.from.dir);
        robot.x = target.x; robot.y = target.y;
        lightIfLetter(robot.x, robot.y);
      } else if (animation.type === 'turn') {
        robot.dir = animation.to.dir;
      } else if (animation.type === 'bump') {
        robot.outOfBounds = true;
        setStatus('Â¡Fuera de lÃ­mites!', true);
        running = false;
        document.getElementById('btnPlay').textContent = 'â–¶';
        try { workspace.highlightBlock(null); } catch(e){}
      }

      animation = { active: false };

      if (robot.outOfBounds) {
        try { workspace.highlightBlock(null); } catch(e){}
        document.getElementById('btnPlay').textContent = 'â–¶';
        drawBoard(robot);
        return;
      }

      if (allLit()) {
        gameWon = true;
        drawBoard(robot);
        setStatus('Â¡Ganaste! STEAM encendidas âœ…');
        running = false;
        try { workspace.highlightBlock(null); } catch(e){}
        document.getElementById('btnPlay').textContent = 'â–¶';
        showWinModal();
        return;
      }

      // Preparar siguiente paso o detener si no hay mÃ¡s
      if (runIdx >= compiled.length) {
        running = false;
        try { workspace.highlightBlock(null); } catch(e){}
        document.getElementById('btnPlay').textContent = 'â–¶';
      }
    }

    function animate(timestamp) {
      if (!running) { rafId = null; return; }

      if (!animation.active) {
        if (runIdx >= compiled.length) {
          running = false;
          document.getElementById('btnPlay').textContent = 'â–¶';
          setStatus('Programa finalizado');
          try { workspace.highlightBlock(null); } catch(e){}
          drawBoard(robot);
          rafId = null;
          return;
        }
        startStep(compiled[runIdx++], timestamp || performance.now());
      }

      const { start, duration, from, to, type } = animation;
      const t = Math.min(1, (timestamp - start) / duration);
      const p = ease(t);

      let current = { ...robot };
      if (type === 'move' || type === 'bump') {
        current.x = from.x + (to.x - from.x) * p;
        current.y = from.y + (to.y - from.y) * p;
        current.dir = from.dir;
      } else if (type === 'turn') {
        const startAngle = from.dir;
        let delta = (to.dir - from.dir + 4) % 4;
        if (delta === 3) delta = -1; // giro antihorario suave
        current.dir = startAngle + delta * p;
      }

      drawBoard(current, animation);

      if (t >= 1) {
        finalizeStep(animation.step);
        drawBoard(robot);
      }

      rafId = requestAnimationFrame(animate);
    }

    function toggleAuto() {
      if (running) {
        running = false;
        animation = { active: false };
        if (rafId) cancelAnimationFrame(rafId);
        try { workspace.highlightBlock(null); } catch(e){}
        document.getElementById('btnPlay').textContent = 'â–¶';
        setStatus('Pausado');
        return;
      }

      // reset
      LETTERS.forEach(L => { L.lit = false; L.color = null; });
      gameWon = false;
      lightIfLetter(startState.x, startState.y);

      compileProgram();
      if (compiled.length === 0) {
        setStatus('Agrega bloques de movimiento debajo de "Programa"');
        return;
      }
      runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      animation = { active: false };
      try { workspace.highlightBlock(null); } catch(e){}
      setStatus('EjecuciÃ³n en curso...');
      drawBoard(robot);

      running = true;
      document.getElementById('btnPlay').textContent = 'â¸';
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(animate);
    }

    function restartRun() {
      running = false;
      animation = { active: false };
      if (rafId) cancelAnimationFrame(rafId);
      LETTERS.forEach(L => { L.lit = false; L.color = null; });
      gameWon = false;
      lightIfLetter(startState.x, startState.y);
      runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      try { workspace.highlightBlock(null); } catch(e){}
      setStatus('Tablero reiniciado');
      drawBoard(robot);
      document.getElementById('btnPlay').textContent = 'â–¶';
    }

    function cleanWorkspace() {
      restartRun();
      workspace.clear();
      const block = workspace.newBlock('start_hat');
      block.initSvg(); block.render();
      block.moveBy(20, 20);
      compiled = []; runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      setStatus('Programa limpio');
      drawBoard(robot);
    }

    document.getElementById('btnPlay').onclick = toggleAuto;
    document.getElementById('btnRestart').onclick = restartRun;
    document.getElementById('btnClean').onclick = cleanWorkspace;
  </script>
</body>
</html>
