<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>STEAM Pathfinder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, sans-serif; }
    .app { display: grid; grid-template-columns: 560px 1fr; gap: 12px; height: 100%; }
    header { grid-column: 1 / -1; padding: 10px 12px; border-bottom: 1px solid #ddd; display:flex; justify-content:space-between; align-items:center; }
    #boardWrap { display:flex; align-items:center; justify-content:center; }
    #board { border: 1px solid #ccc; background: #fff; }
    #controls { display:flex; gap:8px; align-items:center; }
    #status { min-height: 24px; font-weight: 600; }
    #status.ok { color: #0a7a27; }
    #status.err { color: #b00020; }
    .sidebar { padding: 12px; border-left: 1px solid #eee; display:flex; flex-direction:column; gap:8px; }
    #blocklyDiv { width: 100%; height: calc(100% - 40px); border: 1px solid #e6e6e6; border-radius: 10px; box-shadow: 0 2px 10px rgba(31,41,55,.08); }
    button { padding: 10px 16px; border-radius: 10px; border: 1px solid #cbd5e1; background:#f8fafc; cursor:pointer; font-size:16px; }
    button:hover { background:#eef2ff; }
    #controls button { min-width: 48px; }
    #btnPlay, #btnRestart, #btnClean { font-size:18px; padding:12px 18px; }
    .blocklyToolboxDiv { border-right: 1px solid #e5e7eb; background: #ffffff !important; }
    .blocklyFlyoutBackground { fill: #f8fafc !important; }
  </style>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <img id="logoImg" src="./assets/logo.svg" alt="logo" style="height:28px;vertical-align:middle;margin-right:8px;">
        <strong>STEAM Pathfinder</strong> Â· EncendÃ© las letras STEAM pasando por encima con el robot.
      </div>
      <div id="controls">
        <button id="btnPlay" title="Reproducir / Pausar">â–¶</button>
        <button id="btnRestart" title="Reiniciar">â†º</button>
        <button id="btnClean" title="Limpiar">ðŸ§¹</button>
      </div>
    </header>

    <div class="sidebar">
      <div id="status"></div>
      <div id="blocklyDiv"></div>
      <!-- Toolbox sin categorÃ­as: solo bloques de movimiento visibles -->
      <xml id="toolbox" style="display:none">
        <block type="move_forward"></block>
        <block type="turn_left"></block>
        <block type="turn_right"></block>
      </xml>
    </div>

    <div id="boardWrap">
      <canvas id="board"></canvas>
    </div>
  </div>

  <script>
    // ======= Tema (playful) + renderer zelos =======
    const playfulTheme = Blockly.Theme.defineTheme('playful', {
      base: Blockly.Themes.Classic,
      componentStyles: {
        workspaceBackgroundColour: '#fafbff',
        toolboxBackgroundColour: '#ffffff',
        toolboxForegroundColour: '#1f2937',
        flyoutBackgroundColour: '#ffffff',
        insertionMarkerColour: '#4C97FF',
        insertionMarkerOpacity: 0.3,
        scrollbarColour: '#c7d2fe'
      }
    });

    // ======= ImÃ¡genes =======
    const IMAGES = {
      robot: new Image(),
      icons: {
        move: new Image(),
        left: new Image(),
        right: new Image()
      }
    };
    IMAGES.robot.src = './assets/robot.svg';
    IMAGES.icons.move.src = './assets/icons/move.svg';
    IMAGES.icons.left.src = './assets/icons/left.svg';
    IMAGES.icons.right.src = './assets/icons/right.svg';

    // ======= Bloques mÃ­nimos =======
    Blockly.Blocks['start_hat'] = {
      init: function() {
        this.appendDummyInput().appendField("   Play   ");
        this.setNextStatement(true);
        this.setColour("#4C97FF");
        this.setDeletable(false);
        this.setMovable(true);
        this.setInputsInline(true);
        this.setTooltip("Bloque de inicio de programa");
        this.setPreviousStatement(false);
      }
    };
    Blockly.Blocks['move_forward'] = {
      init: function() {
        this.appendDummyInput()
          .appendField(new Blockly.FieldImage('./assets/icons/move.svg', 24, 24, '*'))
          .appendField("avanzar");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setColour("#9966FF");
      }
    };
    Blockly.Blocks['turn_left'] = {
      init: function() {
        this.appendDummyInput()
          .appendField(new Blockly.FieldImage('./assets/icons/left.svg', 24, 24, '*'))
          .appendField("girar izquierda");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setColour("#9966FF");
      }
    };
    Blockly.Blocks['turn_right'] = {
      init: function() {
        this.appendDummyInput()
          .appendField(new Blockly.FieldImage('./assets/icons/right.svg', 24, 24, '*'))
          .appendField("girar derecha");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setColour("#9966FF");
      }
    };

    // ======= Workspace =======
    const workspace = Blockly.inject('blocklyDiv', {
      toolbox: document.getElementById('toolbox'),
      scrollbars: true,
      trashcan: true,
      zoom: { controls: true, wheel: true },
      comments: false,
      collapse: false,
      media: 'https://unpkg.com/blockly/media/',
      renderer: 'zelos',
      theme: playfulTheme
    });

    function ensureStartHat() {
      const hats = workspace.getTopBlocks(true).filter(b => b.type === 'start_hat');
      if (hats.length === 0) {
        const block = workspace.newBlock('start_hat');
        block.initSvg(); block.render();
        block.moveBy(20, 20);
      }
    }
    ensureStartHat();

    document.getElementById('btnClean').onclick = cleanWorkspace;
    document.getElementById('btnRestart').onclick = restartRun;

    // ======= Escenario 3x5 con STEAM en lÃ­nea =======
    const GRID_W = 5;   // columnas
    const GRID_H = 3;   // filas
    const CELL   = 100;
    const PAD    = 10;

    const startState = { x: 0, y: 1, dir: 0 }; // medio de la fila central, mirando al Este

    // Letras STEAM en la fila central (y = 1)
    const LETTERS = [
      { ch: 'S', x: 0, y: 1, lit: false },
      { ch: 'T', x: 1, y: 1, lit: false },
      { ch: 'E', x: 2, y: 1, lit: false },
      { ch: 'A', x: 3, y: 1, lit: false },
      { ch: 'M', x: 4, y: 1, lit: false },
    ];

    function isLetterAt(x, y) {
      return LETTERS.findIndex(L => L.x === x && L.y === y);
    }
    function lightIfLetter(x, y) {
      const idx = LETTERS.findIndex(L => L.x === x && L.y === y);
      if (idx >= 0) LETTERS[idx].lit = true;
    }
    function allLit() {
      return LETTERS.every(L => L.lit);
    }

    // ======= IntÃ©rprete simple =======
    function clampNumber(n, min, max) { if (Number.isNaN(n)) return min; return Math.max(min, Math.min(max, n)); }

    function move(robot) {
      let nx = robot.x, ny = robot.y;
      if (robot.dir === 0) nx += 1;
      else if (robot.dir === 1) ny += 1;
      else if (robot.dir === 2) nx -= 1;
      else if (robot.dir === 3) ny -= 1;

      if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
        robot.x = nx; robot.y = ny;
        lightIfLetter(robot.x, robot.y);
      } else {
        robot.outOfBounds = true;
      }
    }

    // ======= Dibujo =======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    // Ajuste dinÃ¡mico del canvas a 3x5
    canvas.width  = PAD*2 + CELL*GRID_W;
    canvas.height = PAD*2 + CELL*GRID_H;

    function drawBoard(robot = startState) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0,0,canvas.width,canvas.height);

      // Grilla
      ctx.strokeStyle = '#ddd';
      for (let i=0;i<=GRID_W;i++) {
        ctx.beginPath(); ctx.moveTo(PAD + i*CELL, PAD); ctx.lineTo(PAD + i*CELL, PAD + GRID_H*CELL); ctx.stroke();
      }
      for (let j=0;j<=GRID_H;j++) {
        ctx.beginPath(); ctx.moveTo(PAD, PAD + j*CELL); ctx.lineTo(PAD + GRID_W*CELL, PAD + j*CELL); ctx.stroke();
      }

      // Letras
      LETTERS.forEach(L => drawLetterCell(L));

      // Robot
      drawRobot(robot.x, robot.y, robot.dir, robot.outOfBounds || false);
    }

    function drawLetterCell(L) {
      const px = PAD + L.x*CELL, py = PAD + L.y*CELL;
      // color apagado vs encendido
      ctx.fillStyle = L.lit ? '#c7e0ff' : '#fff3bf';
      ctx.fillRect(px+2, py+2, CELL-4, CELL-4);
      // letra
      ctx.fillStyle = '#1f2937';
      ctx.font = 'bold 48px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(L.ch, px + CELL/2, py + CELL/2);
      // marco sutil
      ctx.strokeStyle = L.lit ? '#2563eb' : '#eab308';
      ctx.lineWidth = 3;
      ctx.strokeRect(px+6, py+6, CELL-12, CELL-12);
    }

    function drawRobot(x, y, dir, outOfBounds=false) {
      const cx = PAD + x*CELL + CELL/2;
      const cy = PAD + y*CELL + CELL/2;
      const angle = [0, Math.PI/2, Math.PI, -Math.PI/2][dir] || 0;
      const size = CELL * 0.6;
      if (IMAGES.robot && IMAGES.robot.complete && IMAGES.robot.naturalWidth > 0) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.drawImage(IMAGES.robot, -size/2, -size/2, size, size);
        if (outOfBounds) {
          ctx.strokeStyle = '#e23';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(0, 0, size*0.55, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.restore();
      } else {
        const r = CELL*0.28;
        ctx.fillStyle = outOfBounds ? '#e23' : '#4C97FF';
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
        const nx = cx + Math.cos(angle) * (r+10);
        const ny = cy + Math.sin(angle) * (r+10);
        ctx.strokeStyle = '#003A99'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(nx, ny); ctx.stroke();
      }
    }

    function setStatus(msg, error=false) {
      const el = document.getElementById('status');
      el.textContent = msg; el.className = error ? 'err' : (msg ? 'ok' : '');
    }

    drawBoard();

    // ======= EjecuciÃ³n paso a paso =======
    let running = false;
    let intervalId = null;
    let compiled = [];
    let runIdx = 0;
    let robot = { ...startState, outOfBounds: false };

    function compileProgram() {
      compiled = [];
      const top = workspace.getTopBlocks(true).find(b => b.type === 'start_hat');
      if (!top) return;

      function compileBlock(block) {
        if (!block) return;
        switch (block.type) {
          case 'move_forward': compiled.push({ cmd: 'move', id: block.id }); break;
          case 'turn_left':    compiled.push({ cmd: 'left', id: block.id }); break;
          case 'turn_right':   compiled.push({ cmd: 'right', id: block.id }); break;
        }
      }
      function compileChain(block) {
        let b = block;
        while (b) { compileBlock(b); b = b.getNextBlock(); }
      }
      compileChain(top.getNextBlock());
    }

    function stepOnce() {
      if (runIdx >= compiled.length) { toggleAuto(); return; }
      const step = compiled[runIdx];
      runIdx++;
      try { workspace.highlightBlock(step.id); } catch(e) {}

      switch (step.cmd) {
        case 'move':  move(robot); break;
        case 'left':  robot.dir = (robot.dir + 3) % 4; break;
        case 'right': robot.dir = (robot.dir + 1) % 4; break;
      }

      drawBoard(robot);

      if (robot.outOfBounds) {
        setStatus('Â¡Fuera de lÃ­mites!', true);
        toggleAuto();
        return;
      }
      if (allLit()) {
        setStatus('Â¡Ganaste! Todas las letras STEAM encendidas âœ…');
        toggleAuto();
        return;
      }
    }

    function toggleAuto() {
      if (running) {
        running = false;
        clearInterval(intervalId);
        intervalId = null;
        clearHighlight();
        document.getElementById('btnPlay').textContent = 'â–¶';
      } else {
        // reset de letras y robot
        LETTERS.forEach(L => L.lit = false);
        // encender si empieza parado sobre una letra
        lightIfLetter(startState.x, startState.y);

        compileProgram();
        runIdx = 0;
        robot = { ...startState, outOfBounds: false };
        clearHighlight();
        setStatus('');
        drawBoard(robot);
        running = true;
        intervalId = setInterval(stepOnce, 400);
        document.getElementById('btnPlay').textContent = 'â¸';
      }
    }

    function clearHighlight() {
      try { workspace.highlightBlock(null); } catch(e) {}
    }

    document.getElementById('btnPlay').onclick = toggleAuto;

    function restartRun() {
      if (running) toggleAuto();
      LETTERS.forEach(L => L.lit = false);
      lightIfLetter(startState.x, startState.y);
      runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      clearHighlight();
      setStatus('');
      drawBoard(robot);
    }

    function cleanWorkspace() {
      if (running) toggleAuto();
      workspace.clear();
      const block = workspace.newBlock('start_hat');
      block.initSvg(); block.render();
      block.moveBy(20, 20);
      LETTERS.forEach(L => L.lit = false);
      lightIfLetter(startState.x, startState.y);
      compiled = [];
      runIdx = 0;
      robot = { ...startState, outOfBounds: false };
      clearHighlight();
      setStatus('');
      drawBoard(robot);
    }
  </script>
</body>
</html>
